{
  "Competitive Programming Template": {
    "prefix": "cmain",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "using namespace std;",
      "",
      "#define umap(t,u) unordered_map<t,u>",
      "#define uset(t) unordered_set<t>",
      "#define v(t) vector<t>",
      "#define p(t,u) pair<t,u>",
      "#define rep(i, n) for (size_t i = 0; i < n; ++i)",
      "",
      "using i32 = int;",
      "using i64 = long int;",
      "using u32 = uint32_t;",
      "using u64 = uint64_t;",
      "using usize = size_t;",
      "using f32 = float;",
      "using f64 = double;",
      "",
      "int main() {",
      "  ios::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "  $1",
      "  return 0;",
      "}"
    ],
    "description": "Competitive programming template"
  },
  "BFS Template": {
    "prefix": "bfs",
    "body": [
      "vector<int> bfs(vector<vector<int>>& adj, int start) {",
      "  int n = adj.size();",
      "  vector<int> dist(n, -1);",
      "  queue<int> q;",
      "",
      "  dist[start] = 0;",
      "  q.push(start);",
      "",
      "  while (!q.empty()) {",
      "    int u = q.front();",
      "    q.pop();",
      "",
      "    for (int v : adj[u]) {",
      "      if (dist[v] == -1) {",
      "        dist[v] = dist[u] + 1;",
      "        q.push(v);",
      "      }",
      "    }",
      "  }",
      "",
      "  return dist;",
      "}"
    ],
    "description": "BFS algorithm template"
  },
  "DFS Template": {
    "prefix": "dfs",
    "body": [
      "vector<bool> visited;",
      "",
      "void dfs(vector<vector<int>>& adj, int u) {",
      "  visited[u] = true;",
      "  // Process node u here",
      "  $1",
      "",
      "  for (int v : adj[u]) {",
      "    if (!visited[v]) {",
      "      dfs(adj, v);",
      "    }",
      "  }",
      "}",
      "",
      "// Initialize: visited.assign(n, false);"
    ],
    "description": "DFS algorithm template"
  },
  "Dijkstra Template": {
    "prefix": "dijkstra",
    "body": [
      "vector<ll> dijkstra(vector<vector<pair<int, ll>>>& adj, int start) {",
      "  int n = adj.size();",
      "  vector<ll> dist(n, LLONG_MAX);",
      "  priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> pq;",
      "",
      "  dist[start] = 0;",
      "  pq.push({0, start});",
      "",
      "  while (!pq.empty()) {",
      "    auto [d, u] = pq.top();",
      "    pq.pop();",
      "",
      "    if (d > dist[u]) continue;",
      "",
      "    for (auto [v, w] : adj[u]) {",
      "      if (dist[u] + w < dist[v]) {",
      "        dist[v] = dist[u] + w;",
      "        pq.push({dist[v], v});",
      "      }",
      "    }",
      "  }",
      "",
      "  return dist;",
      "}"
    ],
    "description": "Dijkstra's shortest path algorithm"
  },
  "Bellman-Ford Template": {
    "prefix": "bellmanford",
    "body": [
      "struct Edge {",
      "  int u, v;",
      "  ll w;",
      "};",
      "",
      "pair<vector<ll>, bool> bellmanFord(vector<Edge>& edges, int n, int start) {",
      "  vector<ll> dist(n, LLONG_MAX);",
      "  dist[start] = 0;",
      "",
      "  // Relax edges n-1 times",
      "  for (int i = 0; i < n - 1; i++) {",
      "    for (auto& edge : edges) {",
      "      if (dist[edge.u] != LLONG_MAX && ",
      "          dist[edge.u] + edge.w < dist[edge.v]) {",
      "        dist[edge.v] = dist[edge.u] + edge.w;",
      "      }",
      "    }",
      "  }",
      "",
      "  // Check for negative cycles",
      "  bool hasNegCycle = false;",
      "  for (auto& edge : edges) {",
      "    if (dist[edge.u] != LLONG_MAX && ",
      "        dist[edge.u] + edge.w < dist[edge.v]) {",
      "      hasNegCycle = true;",
      "      break;",
      "    }",
      "  }",
      "",
      "  return {dist, hasNegCycle};",
      "}"
    ],
    "description": "Bellman-Ford algorithm with negative cycle detection"
  },
  "Floyd-Warshall Template": {
    "prefix": "floydwarshall",
    "body": [
      "vector<vector<ll>> floydWarshall(vector<vector<ll>>& dist) {",
      "  int n = dist.size();",
      "",
      "  // Initialize with given distances",
      "  // dist[i][j] should be LLONG_MAX if no direct edge",
      "  // dist[i][i] should be 0",
      "",
      "  for (int k = 0; k < n; k++) {",
      "    for (int i = 0; i < n; i++) {",
      "      for (int j = 0; j < n; j++) {",
      "        if (dist[i][k] != LLONG_MAX && ",
      "            dist[k][j] != LLONG_MAX && ",
      "            dist[i][k] + dist[k][j] < dist[i][j]) {",
      "          dist[i][j] = dist[i][k] + dist[k][j];",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  return dist;",
      "}",
      "",
      "// Usage: Initialize dist[n][n] matrix first",
      "// dist[i][j] = weight if edge exists, LLONG_MAX otherwise",
      "// dist[i][i] = 0 for all i"
    ],
    "description": "Floyd-Warshall all-pairs shortest path algorithm"
  }
}
